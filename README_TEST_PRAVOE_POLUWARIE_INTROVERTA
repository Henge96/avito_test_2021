Описание реализации тестового задания:

Использовал бы архитектуру микросервиса к данному заданию, предполагая возможную масштабируемость.

Реализация предполагала бы разделение на слои:
- api, app - слои получения+валидации данных и слои бизнес логики (в котором был бы реализован process - удаление/обновление/создание данных в глобальной мапе по факту получения тасок).
- adapter/repo - репозиторий для хранения.

Как вариант, хранение в оперативке предполагало бы глобальную мапу:
    cashMap := make(map[string]app.User)
    Ключи, например, идентификатор, а значение - это сама сущность.

Интерфейсы + структуры

api слой -

type Application interface {
	Create(ctx context.Context, app.User) (app.User, error)
	Update(ctx, updateParams updateParams) error
	Delete(ctx context.Context, userID uuid.UUID) error
	GetUsers(ctx context.Context, params Params) ([]app.User, total, error)
}

type Api struct {
	app Application
}

app слой -

type Repo interface {
    TaskRepo
	Create(ctx context.Context, user User) (User, error)
	Delete(ctx context.Context, userID uuid.UUID) error
}
// Метода получения данных в репо нет, тк забирать их будем из мапы.

type TaskRepo interface {
		SaveTask(context.Context, Task) (uuid.UUID, error)
		FinishTask(context.Context, uuid.UUID) error
		ListActualTask(context.Context, int) ([]Task, error)
}

type Core struct {
	repo     Repo
}

type Task struct {
		ID         uuid.UUID
		UserID     uuid.UUID
		Kind       TaskKind
		CreatedAt  time.Time
		UpdatedAt  time.Time
		FinishedAt time.Time
}

type User struct {
     ID uuid.UUID
     ...
     ...
     ...
}

В ручках идет реализация создания/удаления/обновления записей с апи слоя в бд.
В каждой ручке дополнительно к созданию записи в таблице сущности создается таска на добавление ее в таблицу тасок.

Параллельно в горутине запущен Process - он берет все не завершенные таски и добавляет их в мапу.

Примерно:

const (
		taskTickerTimeout = time.Second
		taskLimit         = 10
	)

		ticker = time.NewTicker(taskTickerTimeout)

	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			tasks, err := a.repo.ListActualTask(ctx, taskLimit)
			if err != nil {
				log.Error("couldn't get tasks", zap.Error(err))

				continue
			}

			for i := range tasks {

			switch tasks.Kind {
			case TaskKindEventAdd:
		    // добавление в мапу -> затем a.repo.FinishTask

		    case TaskKindEventDel:
		    // удаление из мапы -> затем a.repo.FinishTask

            case TaskKindEventUpdate:
		    // обновление из мапы -> затем a.repo.FinishTask
            }
          }

Важно защитить мапу мьютексами для изменения данных.
Пример сохранения таски аналогичен с добавлением транзакции в app/handlers тестового в текущем репозитории,
сборка приложения предполагась бы аналогичной.

Механизм сохранения тасок в базу и последующего обновления мапы предполагается для отсутствия потери данных при рестартах.
Скажем данные в мапе(кэше или бд ключ-значения) - хранятся Х часов, в данном случае мы не потеряем не сохраненную информацию,
при рестарте мы возьмем все не зафинишированные таски. Если это не существенно и, скажем, после выключения приложения все стирается,
то можно просто после изменения инфы в бд без таски хранить данные в мапу.

Метода получения списка из репо нет в связи с тем, что данные будут получены из мапы в app слое.


